head	2.1;
access;
symbols
	mksh-R20:2.1
	mksh-R19:2.1
	cvs-200412101800:1.1.15.1
	mirbsd:1.1.15;
locks; strict;
comment	@ * @;


2.1
date	2004.12.10.18.09.41;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2004.12.10.18.08.08;	author tg;	state Exp;
branches
	1.1.15.1;
next	;

1.1.15.1
date	2004.12.10.18.08.08;	author tg;	state Exp;
branches;
next	;


desc
@@


2.1
log
@bump to mksh R19
@
text
@/**	$MirBSD: src/bin/ksh/expand.h,v 1.1.15.1 2004/12/10 18:08:08 tg Exp $ */
/*	$OpenBSD: expand.h,v 1.3 2001/03/26 16:19:45 todd Exp $	*/

#ifndef EXPAND_H
#define EXPAND_H

/*
 * Expanding strings
 */

#define X_EXTRA		8	/* this many extra bytes in X string */

#if 0				/* Usage */
	XString xs;
	char *xp;

	Xinit(xs, xp, 128, ATEMP); /* allocate initial string */
	while ((c = generate()) {
		Xcheck(xs, xp);	/* expand string if necessary */
		Xput(xs, xp, c); /* add character */
	}
	return Xclose(xs, xp);	/* resize string */
/*
 * NOTE:
 *     The Xcheck and Xinit macros have a magic + X_EXTRA in the lengths.
 *     This is so that you can put up to X_EXTRA characters in a XString
 *     before calling Xcheck. (See yylex in lex.c)
 */
#endif /* 0 */

typedef struct XString {
	char   *end, *beg;	/* end, begin of string */
	size_t	len;		/* length */
	Area	*areap;		/* area to allocate/free from */
} XString;

typedef char * XStringP;

/* initialize expandable string */
#define	Xinit(xs, xp, length, area) do { \
			(xs).len = length; \
			(xs).areap = (area); \
			(xs).beg = alloc((xs).len + X_EXTRA, (xs).areap); \
			(xs).end = (xs).beg + (xs).len; \
			xp = (xs).beg; \
		} while (0)

/* stuff char into string */
#define	Xput(xs, xp, c)	(*xp++ = (c))

/* check if there are at least n bytes left */
#define	XcheckN(xs, xp, n) do { \
		    int more = ((xp) + (n)) - (xs).end; \
		    if (more > 0) \
			xp = Xcheck_grow_(&xs, xp, more); \
		} while (0)

/* check for overflow, expand string */
#define Xcheck(xs, xp)	XcheckN(xs, xp, 1)

/* free string */
#define	Xfree(xs, xp)	afree((void*) (xs).beg, (xs).areap)

/* close, return string */
#define	Xclose(xs, xp)	(char*) aresize((void*)(xs).beg, \
					(size_t)((xp) - (xs).beg), (xs).areap)
/* begin of string */
#define	Xstring(xs, xp)	((xs).beg)

#define Xnleft(xs, xp) ((xs).end - (xp))	/* may be less than 0 */
#define	Xlength(xs, xp) ((xp) - (xs).beg)
#define Xsize(xs, xp) ((xs).end - (xs).beg)
#define	Xsavepos(xs, xp) ((xp) - (xs).beg)
#define	Xrestpos(xs, xp, n) ((xs).beg + (n))

char *	Xcheck_grow_(XString *xsp, char *xp, size_t more);

/*
 * expandable vector of generic pointers
 */

typedef struct XPtrV {
	void  **cur;		/* next avail pointer */
	void  **beg, **end;	/* begin, end of vector */
} XPtrV;

#define	XPinit(x, n) do { \
			void **vp__; \
			vp__ = (void**) alloc(sizeofN(void*, n), ATEMP); \
			(x).cur = (x).beg = vp__; \
			(x).end = vp__ + n; \
		    } while (0)

#define	XPput(x, p) do { \
			if ((x).cur >= (x).end) { \
				int n = XPsize(x); \
				(x).beg = (void**) aresize((void*) (x).beg, \
						   sizeofN(void*, n*2), ATEMP); \
				(x).cur = (x).beg + n; \
				(x).end = (x).cur + n; \
			} \
			*(x).cur++ = (p); \
		} while (0)

#define	XPptrv(x)	((x).beg)
#define	XPsize(x)	((x).cur - (x).beg)

#define	XPclose(x)	(void**) aresize((void*)(x).beg, \
					 sizeofN(void*, XPsize(x)), ATEMP)

#define	XPfree(x)	afree((void*) (x).beg, ATEMP)

#endif	/* ndef EXPAND_H */
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/**	$MirBSD: src/bin/ksh/expand.h,v 1.6 2004/10/28 11:53:41 tg Exp $ */
@


1.1.15.1
log
@Import mirbsdksh-HEAD into new CVS
@
text
@@
