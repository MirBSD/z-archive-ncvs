head	2.2;
access;
symbols
	cgiirc-0_5_5:1.1.3.2
	cgiirc-0_5_4:1.1.3.1
	tg:1.1.3;
locks; strict;
comment	@# @;


2.2
date	2005.01.18.20.26.31;	author tg;	state dead;
branches;
next	2.1;

2.1
date	2004.12.19.14.29.17;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2004.12.19.14.26.30;	author tg;	state Exp;
branches
	1.1.3.1;
next	;

1.1.3.1
date	2004.12.19.14.26.30;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2005.01.18.20.03.58;	author tg;	state Exp;
branches;
next	;


desc
@@


2.2
log
@nah, doesnt work like I would
@
text
@# $Id: Event.pm,v 1.1.3.1 2004/10/27 10:56:50 tg Exp $
package Event;
use strict;
my($currentevent,$currenteventid,$stop);

sub new {
   my $self = bless { }, shift;
   %$self = @@_;
   return $self;
}

sub add {
   my($self,$event,%option) = @@_;
   return unless $event;
   $self->{$event} ||= [ ];

   push(@@{$self->{$event}}, bless ( {
       priority => $option{priority} || 5,
	   code => $option{code},
	   data => $option{data},
	   'package' => (caller)[0],
	   _self => $self,
	 } ) );
   $self->sortpri($event);
}

sub delete {
   my($self,$event,%option) = @@_;
   if(defined $currentevent) {
      $self = $self->{_self};
      splice( @@{ $self->{$currentevent} }, $currenteventid, 1);
      $self->sortpri($currentevent);
   } else {
      my $count = 0;
      for my $item(@@{ $self->{$event} } ) {
         if((exists $option{code} && $item->{code} eq $option{code}) || (exists $option{data} && $item->{data} eq $option{data})) {
	        splice( @@{ $self->{$event} }, $count, 1);
	     }
	     $count++;
      }
      $self->sortpri($event);
   }
}

sub remove_package {
   my($self, $package) = @@_;
   for my $event (keys %$self) {
      next unless ref $self->{$event};
      my $count = 0;
      for my $item(@@{ $self->{$event} } ) {
	     if($item->{package} eq $package) {
		    splice( @@{ $self->{$event} }, $count, 1);
		 }
		 $count++;
      }
   }   
}

# Make sure the array for the event is sorted on priority
sub sortpri {
   my($self,$event) = @@_;
   return unless $event;

   if($#{$self->{$event}} == -1) {
      delete($self->{$event});
   } else {
      @@{$self->{$event}} = (sort {$a->{priority} <=> $b->{priority}} @@{$self->{$event}});
   }
}

sub handle {
   my($self,$event,@@param) = @@_;
   print("Event: $event, @@param\n") if $self->{_DEBUG};
   $currentevent = $event;
   $currenteventid = 0;
   for my $item(@@{$self->{$event}} ) {
      my($tmpevent,$tmpid) = ($currentevent,$currenteventid);
      $item->{code}->($item,@@param);
	  ($currentevent,$currenteventid) = ($tmpevent,$tmpid);
	  $currenteventid++;
	  if($stop) {
	     $stop = 0;
		 last;
	  }
   }
   if(!scalar @@{$self->{$event}} && $event ne "unhandled") {
      $self->handle('unhandled', $event, @@param);
   }
   $currenteventid = $currentevent = undef;
}

sub stop {
   my($self) = @@_;
   $stop = 1 if defined $currentevent;
}

sub getevent {
   my($self) = @@_;
   return defined $currentevent ? $currentevent : undef;
}

sub exists {
   my($self,$event) = @@_;
   return 1 if exists $self->{$event};
   0;
}

1;
@


2.1
log
@*sigh* update to MirCGIIRC
@
text
@@


1.1
log
@Initial revision
@
text
@@


1.1.3.1
log
@Import cgiirc 0.5.4 (pristine) again
@
text
@@


1.1.3.2
log
@there's a new CGI::IRC out, with utf-8 supposedly, and fireschrott bugfixes
@
text
@d1 1
a1 1
# $Id: Event.pm,v 1.1.1.1 2002/03/05 16:34:19 dgl Exp $
@

