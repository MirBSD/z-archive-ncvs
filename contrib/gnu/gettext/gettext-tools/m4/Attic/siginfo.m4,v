head	1.2;
access;
symbols
	cvs-200408041120:1.1.2.1 FSF:1.1.2;
locks; strict;
comment	@# @;


1.2
date	2004.08.04.11.47.46;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2004.08.04.11.32.58;	author tg;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2004.08.04.11.32.58;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@die baby die
@
text
@# siginfo.m4 serial 1 (gettext-0.11)
dnl Copyright (C) 2001-2002 Free Software Foundation, Inc.
dnl This file is free software, distributed under the terms of the GNU
dnl General Public License.  As a special exception to the GNU General
dnl Public License, this file may be distributed as part of a program
dnl that contains a configuration script generated by Autoconf, under
dnl the same distribution terms as the rest of that program.

# Determine how to determine the precise cause of a signal, for example
# division by zero.
# - SUSV2 and POSIX specify the use of sigaction with SA_SIGINFO and a member
#   void (*)(int sig, siginfo_t *info, void *context) sa_sigaction.
#   Linux (2.2.x and newer) and Solaris implement this.
#   Linux (2.4.x and newer) on i386, m68k, sparc, sparc64, ia64 actually
#   deliver FPE_INTDIV.
# - Without SA_SIGINFO:
#   - Linux on m68k calls the handler as
#     void (*)(int sig, int code, struct sigcontext* scp).
#     For division by zero, code would be VEC_ZERODIV<<2.
#   - Linux on sparc calls the handler either as
#     void (*)(int sig, int code, struct sigcontext* scp),
#     code for division by zero would be SUBSIG_IDIVZERO, or as
#     void (*)(int sig, siginfo_t *info, void *context).
#     Which one depends on a process specific flag in the kernel.
#   - Linux on sparc64 always calls the handler as
#     void (*)(int sig, siginfo_t *info, void *context).
#   - FreeBSD on i386 calls the handler as
#     void (*)(int sig, int code, void* scp, char* addr).
#     For division by zero, code would be FPE_INTDIV.
#   - SunOS 4 calls the handler as
#     void (*)(int sig, int code, void* scp, char* addr).
#   - Solaris?
#   - Irix 5, OSF/1, AIX call the handler as
#     void (*)(int sig, int code, struct sigcontext *scp).
# These are so many OS and CPU dependencies that we don't bother, and rely
# only on SA_SIGINFO.
AC_DEFUN([gt_SIGINFO],
[
  AC_CACHE_CHECK([for signal handlers with siginfo_t], gt_cv_siginfo_t,
    [AC_TRY_COMPILE([
#include <signal.h>], [
struct sigaction action;
siginfo_t info;
action.sa_flags = SA_SIGINFO;
action.sa_sigaction = (void *) 0;
], gt_cv_siginfo_t=yes, gt_cv_siginfo_t=no)])
  if test $gt_cv_siginfo_t = yes; then
    AC_DEFINE(HAVE_SIGINFO, 1,
      [Define to 1 if <signal.h> defines the siginfo_t type,
   and struct sigaction has the sa_sigaction member and the SA_SIGINFO flag.])
  fi
])
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@GNU gettext from :pserver:anoncvs@@sources.redhat.com:/cvs/gettext pass anoncvs
@
text
@@
